# Clean-Code-Course

1. Introducción al Código Limpio
   - Introducción al concepto de código limpio y su importancia
   - ¿Qué se entiende como código incorrecto?
   - Las consecuencias de un código incorrecto en términos económicos
   - La importancia de la actitud frente al cambio
   - Los conceptos del código limpio
   - Las diferencias teóricas del concepto
   - La Regla del Boy Scout y los principios del código limpio
[2. La importancia de los nombres](02-Naming/README.md)
    - El nombre debe revelar las intenciones
    - El problema de la desinformación involuntaria a través del nombrado
    - Legibilidad y búsqueda de nombres
    - Prefijos, interfaces, implementaciones y notación húngara
    - El problema de la asignación mental
    - Nombrado de clases y métodos
    - Un concepto, una palabra
    - Juegos de palabras, un error a evitar
    - Nombrado de dominios de problemas y soluciones
    - Contextos innecesarios, una distracción a evitar
3. Las funciones en el código limpio
   - El tamaño de las funciones importa
   - La estructura de bloques y la indentación de las funciones
   - Una función, una funcionalidad
   - La regla descendente y el nivel de abstracción único de las funciones
   - Las instrucciones de tipo Switch
   - La importancia del nombrado de las funciones
   - Cómo plantear de forma limpia los argumentos en las funciones
   - La programación funcional y las formas monádicas habituales
   - Los argumentos de indicador
   - Las tríadas
   - Objetos y listas de argumentos
   - La importancia de los verbos y las palabras clave
   - Los argumentos de salida de una función y sus efectos secundarios
   - Separación de consultas
   - Una excepción, siempre mejor que un código de error
   - La importancia de los bloques try/catch
   - No te repitas (NRY)
   - La programación estructurada
   - Creación de funciones limpias
4. Documentando a través de comentarios
5. Formato del código
6. Los Objetos y otras estructuras de datos
7. El procesamiento correcto de Errores
8. Los límites de nuestro código
9. Pruebas limpias
10. La organización de las clases
11. Sistemas
12. Diseños Emergentes
13. La Concurrencia
14. Argumentos
15. JUnit y pruebas unitarias
16. SerialDate: Refactorización
17. Hablando de Síntomas y Heurística
18. Introducción a la Arquitectura Limpia
